diff -up openwsman-2.6.8/src/server/shttpd/shttpd.c.orig openwsman-2.6.8/src/server/shttpd/shttpd.c
--- openwsman-2.6.8/src/server/shttpd/shttpd.c.orig	2019-03-13 09:32:32.417633057 +0100
+++ openwsman-2.6.8/src/server/shttpd/shttpd.c	2019-03-13 09:58:04.482486589 +0100
@@ -705,11 +705,11 @@ parse_http_request(struct conn *c)
 		_shttpd_send_server_error(c, 500, "Cannot allocate request");
 	}
 
+	io_inc_tail(&c->rem.io, req_len);
+
 	if (c->loc.flags & FLAG_CLOSED)
 		return;
 
-	io_inc_tail(&c->rem.io, req_len);
-
 	DBG(("Conn %d: parsing request: [%.*s]", c->rem.chan.sock, req_len, s));
 	c->rem.flags |= FLAG_HEADERS_PARSED;
 
@@ -975,7 +975,7 @@ write_stream(struct stream *from, struct
 }
 
 
-static void
+static int
 connection_desctructor(struct llhead *lp)
 {
 	struct conn		*c = LL_ENTRY(lp, struct conn, link);
@@ -999,7 +999,8 @@ connection_desctructor(struct llhead *lp
 	 * Check the "Connection: " header before we free c->request
 	 * If it its 'keep-alive', then do not close the connection
 	 */
-	do_close = (c->ch.connection.v_vec.len >= vec.len &&
+	do_close = c->rem.flags & FLAG_CLOSED ||
+	    (c->ch.connection.v_vec.len >= vec.len &&
 	    !_shttpd_strncasecmp(vec.ptr,c->ch.connection.v_vec.ptr,vec.len)) ||
 	    (c->major_version < 1 ||
 	    (c->major_version >= 1 && c->minor_version < 1));
@@ -1021,7 +1022,7 @@ connection_desctructor(struct llhead *lp
 		io_clear(&c->loc.io);
 		c->birth_time = _shttpd_current_time;
 		if (io_data_len(&c->rem.io) > 0)
-			process_connection(c, 0, 0);
+			return 1;
 	} else {
 		if (c->rem.io_class != NULL)
 			c->rem.io_class->close(&c->rem);
@@ -1032,6 +1033,8 @@ connection_desctructor(struct llhead *lp
 
 		free(c);
 	}
+
+	return 0;
 }
 
 static void
@@ -1039,7 +1042,7 @@ worker_destructor(struct llhead *lp)
 {
 	struct worker	*worker = LL_ENTRY(lp, struct worker, link);
 
-	free_list(&worker->connections, connection_desctructor);
+	free_list(&worker->connections, (void (*)(struct llhead *))connection_desctructor);
 	free(worker);
 }
 
@@ -1072,6 +1075,8 @@ add_to_set(int fd, fd_set *set, int *max
 static void
 process_connection(struct conn *c, int remote_ready, int local_ready)
 {
+again:
+
 	/* Read from remote end if it is ready */
 	if (remote_ready && io_space_len(&c->rem.io))
 		read_stream(&c->rem);
@@ -1100,7 +1105,11 @@ process_connection(struct conn *c, int r
 	if ((_shttpd_current_time > c->expire_time) ||
 	    (c->rem.flags & FLAG_CLOSED) ||
 	    ((c->loc.flags & FLAG_CLOSED) && !io_data_len(&c->loc.io)))
-		connection_desctructor(&c->link);
+		if (connection_desctructor(&c->link)) {
+			remote_ready = 0;
+			local_ready = 0;
+			goto again;
+		}
 }
 
 static int
@@ -1642,7 +1651,7 @@ worker_function(void *param)
 	while (worker->exit_flag == 0)
 		poll_worker(worker, 1000 * 10);
 
-	free_list(&worker->connections, connection_desctructor);
+	free_list(&worker->connections, (void (*)(struct llhead *))connection_desctructor);
 	free(worker);
 }
 
